import Web3, { ContractInstance } from 'web3';
import FakeProvider from 'web3-fake-provider';
import BigNumber from 'bignumber.js';

import {
  DeferredTransactionWrapper,
  ITxParams,
  TypeChainContract
} from '../types/typechain-runtime';

import { AbiDefinition } from '@0xproject/types';

/**
 * Provides a harness to test autogenerated contract types
 */
export class TestContract<T extends TypeChainContract> {
  private mockWeb3: Web3;
  private mockProvider: FakeProvider;

  private contract: T;
  private mockWeb3Contract: ContractInstance;

  constructor(contractName: string, private address: string, contractCode?: string) {
    this.mockProvider = new FakeProvider();
    this.mockWeb3 = new Web3(this.mockProvider);

    this.mockWeb3Contract = {
      address: address,
      abi: require(`../node_modules/market-solidity/build/contracts/${contractName}.json`)
    };

    spyOn(this.mockWeb3.eth, 'getCode').and.callFake(
      (addr: string, cb: (err: Error, code: string) => void) => {
        expect(addr).toEqual(address);
        cb(null, contractCode || '0x234');
      }
    );

    spyOn(this.mockWeb3.eth, 'contract')
      .and.callFake((abi: AbiDefinition[]) => {
        expect(abi).toEqual(this.mockWeb3Contract.abi);
      })
      .and.returnValue({
        at: addr => {
          expect(addr).toEqual(address);
          return this.mockWeb3Contract;
        }
      });
  }

  /**
   * Creates the contract type for the specified class
   *
   * @param contractClass The contract type class
   */
  public async createContract(
    createMethod: (web3: any, address: string | BigNumber) => Promise<T>
  ) {
    this.contract = await createMethod(this.mockWeb3, this.address);
    return this.contract;
  }

  /**
   * Mocks out a web3 method
   *
   * @param methodName The method to mock out
   * @param expected The expected return value
   * @param expectedArgs The expected arguments
   */
  public setupWeb3Mock(methodName: keyof T, expected: any, ...expectedArgs: any[]) {
    this.mockWeb3Contract[methodName] = this.createMethodSpy(expectedArgs, expected);
  }

  /**
   * Mocks out a web3 transactional method
   *
   * @param methodName The method to mock out
   * @param txArgs The expected transaction args
   * @param expectedArgs The expected arguments
   */
  public setupWeb3TxMock(methodName: keyof T, txArgs?: ITxParams, ...expectedArgs: any[]) {
    const web3MethodName = methodName.slice(0, methodName.length - 2);
    const expectedData = '0x128782984';

    txArgs = txArgs || {
      from: '0x237893629'
    };

    this.mockWeb3Contract[web3MethodName] = {
      sendTransaction: this.createMethodSpy(expectedArgs.concat(txArgs)),
      getData: jasmine.createSpy().and.callFake((...args) => {
        for (let i = 0; i < expectedArgs.length; i++) {
          expect(args[i]).toEqual(expectedArgs[i].toString());
        }
        return expectedData;
      })
    };
  }

  /**
   * Tests the specified method and ensures the method is called with the correct args and returns the correct value
   *
   * @param methodName The method name
   * @param expectedArgs The expected arguments
   * @param expected The expected return value
   */
  public async assertMethod<N>(method: Promise<N>, expected?: N) {
    const result = await method;

    expect(result).toBe(expected);
  }

  /**
   * Tests a getter method and ensures the method returns the correct value
   *
   * @param methodName The method name
   * @param expected The expected return value
   */
  public async testGetterMethod(methodName: string, expected: any) {
    this.mockWeb3Contract[methodName] = this.createMethodSpy([], expected);

    expect(this.contract[methodName]).not.toBeUndefined();
    const result = await this.contract[methodName];

    expect(result).toBe(expected);
    expect(this.mockWeb3Contract[methodName]).toHaveBeenCalled();
  }

  /**
   * Tests the specified transactional method and ensures the method is called with the correct args
   *
   * @param methodName The method name
   * @param expectedArgs The expected arguments
   * @param expected The expected return value
   */
  public async assertTxMethod(
    method: DeferredTransactionWrapper<ITxParams>,
    txArgs?: ITxParams,
    expected?: any
  ) {
    const txResult = await method.send(txArgs);
    expect(txResult).toBe(expected);

    const txResultCustomWeb3 = await method.send(txArgs, this.mockWeb3);
    expect(txResultCustomWeb3).toBe(expected);

    const expectedData = '0x128782984';
    const dataResult = await method.getData();
    expect(dataResult).toBe(expectedData);
  }

  private createMethodSpy(expectedArgs: any[], expected?: any, error?: any) {
    return jasmine.createSpy().and.callFake((...args) => {
      for (let i = 0; i < expectedArgs.length; i++) {
        if (typeof expectedArgs[i] === 'number') {
          expect(args[i]).toEqual(expectedArgs[i].toString());
        } else {
          expect(args[i]).toEqual(expectedArgs[i]);
        }
      }

      const cb = args[args.length - 1];

      cb(error, expected);
    });
  }
}
