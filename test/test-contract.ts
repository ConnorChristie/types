import Web3 from 'web3';
import FakeProvider from 'web3-fake-provider';

import { TypeChainContract } from '../types/typechain-runtime';

/**
 * Provides a harness to test autogenerated contract types
 */
export class TestContract<T extends TypeChainContract> {
  private mockWeb3: any;
  private mockProvider: any;

  private contract: T;
  private mockWeb3Contract: any = {};

  constructor(contractName: string, private address: string) {
    this.mockProvider = new FakeProvider();
    this.mockWeb3 = new Web3(this.mockProvider);

    const actualAbi = require(`../node_modules/market-solidity/build/contracts/${contractName}.json`);

    this.mockWeb3.eth = {
      getCode: (addr, cb) => {
        expect(addr).toEqual(address);
        cb(null, '0x234');
      },
      contract: abi => {
        expect(abi).toEqual(actualAbi.abi);

        return {
          at: addr => {
            expect(addr).toEqual(address);
            return this.mockWeb3Contract;
          }
        };
      }
    };
  }

  /**
   * Creates the contract type for the specified class
   *
   * @param contractClass The contract type class
   */
  public async createContract(contractClass: any) {
    this.contract = await contractClass.createAndValidate(this.mockWeb3, this.address);
  }

  /**
   * Tests the specified method and ensures the method is called with the correct args and returns the correct value
   *
   * @param methodName The method name
   * @param expectedArgs The expected arguments
   * @param expected The expected return value
   */
  public async testMethod(methodName: string, expectedArgs: any[], expected?: any) {
    this.mockWeb3Contract[methodName] = this.createMethodSpy(expectedArgs, expected);

    expect(this.contract[methodName]).not.toBeUndefined();
    const result = await this.contract[methodName](...expectedArgs);

    expect(result).toBe(expected);
    expect(this.mockWeb3Contract[methodName]).toHaveBeenCalled();
  }

  /**
   * Tests the specified transactional method and ensures the method is called with the correct args
   *
   * @param methodName The method name
   * @param expectedArgs The expected arguments
   * @param expected The expected return value
   */
  public async testTxMethod(methodName: string, expectedArgs: any[], expected?: any) {
    this.mockWeb3Contract[methodName] = {
      sendTransaction: this.createMethodSpy(expectedArgs)
    };

    expect(this.contract[`${methodName}Tx`]).not.toBeUndefined();
    const result = await this.contract[`${methodName}Tx`](...expectedArgs).send({});

    expect(result).toBe(expected);
    expect(this.mockWeb3Contract[methodName].sendTransaction).toHaveBeenCalled();
  }

  private createMethodSpy(expectedArgs: any[], expected?: any) {
    return jasmine.createSpy().and.callFake((...args) => {
      for (let i = 0; i < args.length - 1; i++) {
        expect(args[i]).toEqual(expectedArgs[i]);
      }

      args[args.length - 1](null, expected);
    });
  }
}
