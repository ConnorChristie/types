import Web3 from 'web3';
import FakeProvider from 'web3-fake-provider';

import {
  DeferredTransactionWrapper,
  ITxParams,
  TypeChainContract
} from '../types/typechain-runtime';

/**
 * Provides a harness to test autogenerated contract types
 */
export class TestContract<T extends TypeChainContract> {
  private mockWeb3: any;
  private mockProvider: any;

  private contract: T;
  private mockWeb3Contract: any = {};

  constructor(contractName: string, private address: string, contractCode?: string) {
    this.mockProvider = new FakeProvider();
    this.mockWeb3 = new Web3(this.mockProvider);

    const actualAbi = require(`../node_modules/market-solidity/build/contracts/${contractName}.json`);

    this.mockWeb3.eth = {
      getCode: (addr, cb) => {
        expect(addr).toEqual(address);
        cb(null, contractCode || '0x234');
      },
      contract: abi => {
        expect(abi).toEqual(actualAbi.abi);

        return {
          at: addr => {
            expect(addr).toEqual(address);
            return this.mockWeb3Contract;
          }
        };
      }
    };
  }

  /**
   * Creates the contract type for the specified class
   *
   * @param contractClass The contract type class
   */
  public async createContract(contractClass: any) {
    this.contract = await contractClass.createAndValidate(this.mockWeb3, this.address);
  }

  /**
   * Tests the specified method and ensures the method is called with the correct args and returns the correct value
   *
   * @param methodName The method name
   * @param expectedArgs The expected arguments
   * @param expected The expected return value
   */
  public async testMethod(methodName: string, expectedArgs: any[], expected?: any) {
    this.mockWeb3Contract[methodName] = this.createMethodSpy(expectedArgs, expected);

    expect(this.contract[methodName]).not.toBeUndefined();
    const result = await this.contract[methodName](...expectedArgs);

    expect(result).toBe(expected);
    expect(this.mockWeb3Contract[methodName]).toHaveBeenCalled();

    // Test error path
    this.mockWeb3Contract[methodName] = this.createMethodSpy(expectedArgs, null, 'ERROR!!');
    expect(this.contract[methodName]).not.toBeUndefined();

    try {
      await this.contract[methodName](...expectedArgs);

      fail();
    } catch (e) {
      expect(e).toEqual('ERROR!!');
      expect(this.mockWeb3Contract[methodName]).toHaveBeenCalled();
    }
  }

  /**
   * Tests a getter method and ensures the method returns the correct value
   *
   * @param methodName The method name
   * @param expected The expected return value
   */
  public async testGetterMethod(methodName: string, expected: any) {
    this.mockWeb3Contract[methodName] = this.createMethodSpy([], expected);

    expect(this.contract[methodName]).not.toBeUndefined();
    const result = await this.contract[methodName];

    expect(result).toBe(expected);
    expect(this.mockWeb3Contract[methodName]).toHaveBeenCalled();
  }

  /**
   * Tests the specified transactional method and ensures the method is called with the correct args
   *
   * @param methodName The method name
   * @param expectedArgs The expected arguments
   * @param expected The expected return value
   */
  public async testTxMethod(
    methodName: string,
    expectedArgs: any[],
    expected?: any,
    txArgs?: ITxParams
  ) {
    const expectedData = '0x128782984';
    txArgs = txArgs || {
      from: '0x237893629'
    };

    this.mockWeb3Contract[methodName] = {
      sendTransaction: this.createMethodSpy(expectedArgs.concat(txArgs)),
      getData: jasmine.createSpy().and.callFake((...args) => {
        expect(args).toEqual(expectedArgs);
        return expectedData;
      })
    };

    expect(this.contract[`${methodName}Tx`]).not.toBeUndefined();

    const methodResult: DeferredTransactionWrapper<ITxParams> = await this.contract[
      `${methodName}Tx`
    ](...expectedArgs);

    const txResult = await methodResult.send(txArgs);
    expect(txResult).toBe(expected);

    const txResultCustomWeb3 = await methodResult.send(txArgs, this.mockWeb3);
    expect(txResultCustomWeb3).toBe(expected);

    const dataResult = await methodResult.getData();
    expect(dataResult).toBe(expectedData);

    expect(this.mockWeb3Contract[methodName].sendTransaction).toHaveBeenCalled();
    expect(this.mockWeb3Contract[methodName].getData).toHaveBeenCalled();
  }

  private createMethodSpy(expectedArgs: any[], expected?: any, error?: any) {
    return jasmine.createSpy().and.callFake((...args) => {
      for (let i = 0; i < args.length - 1; i++) {
        expect(args[i]).toEqual(expectedArgs[i]);
      }

      const cb = args[args.length - 1];

      cb(error, expected);
    });
  }
}
